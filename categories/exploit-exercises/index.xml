<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Exploit Exercises on Mike Boya</title>
    <link>https://mike-boya.github.io/categories/exploit-exercises/</link>
    <description>Recent content in Exploit Exercises on Mike Boya</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 22 Feb 2016 00:00:00 +0000</lastBuildDate><atom:link href="https://mike-boya.github.io/categories/exploit-exercises/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Exploit Exercises Nebula Level15</title>
      <link>https://mike-boya.github.io/blog/exploit-exercises-nebula-level15/</link>
      <pubDate>Mon, 22 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://mike-boya.github.io/blog/exploit-exercises-nebula-level15/</guid>
      <description>&lt;p&gt;The &lt;em&gt;About&lt;/em&gt; section for &lt;a href=&#34;https://exploit-exercises.com/nebula/level15/&#34; title=&#34;Level15&#34;&gt;Level15&lt;/a&gt; contains the following instructions:&lt;/p&gt;
&lt;p&gt;&amp;ldquo;strace the binary at /home/flag15/flag15 and see if you spot anything out of the ordinary.&lt;/p&gt;
&lt;p&gt;You may wish to review how to “compile a shared library in linux” and how the libraries are loaded and processed by reviewing the dlopen manpage in depth.&lt;/p&gt;
&lt;p&gt;Clean up after yourself :)&amp;rdquo;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Exploit Exercises Nebula Level16</title>
      <link>https://mike-boya.github.io/blog/exploit-exercises-nebula-level16/</link>
      <pubDate>Mon, 22 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://mike-boya.github.io/blog/exploit-exercises-nebula-level16/</guid>
      <description>&lt;p&gt;For &lt;a href=&#34;https://exploit-exercises.com/nebula/level16/&#34; title=&#34;Level16&#34;&gt;Level16&lt;/a&gt;, we are told that a perl script is running on port 1616.&lt;/p&gt;
&lt;p&gt;The source code for that script is provided:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    #!/usr/bin/env perl

    use CGI qw{param};

    print &amp;quot;Content-type: text/html\n\n&amp;quot;;

    sub login {
      $username = $_[0];
      $password = $_[1];

      $username =~ tr/a-z/A-Z/; # conver to uppercase
      $username =~ s/\s.*//;        # strip everything after a space

      @output = `egrep &amp;quot;^$username&amp;quot; /home/flag16/userdb.txt 2&amp;gt;&amp;amp;1`;
      foreach $line (@output) {
          ($usr, $pw) = split(/:/, $line);


          if($pw =~ $password) {
              return 1;
          }
      }

      return 0;
    }

    sub htmlz {
      print(&amp;quot;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;Login resuls&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;quot;);
      if($_[0] == 1) {
          print(&amp;quot;Your login was accepted&amp;lt;br/&amp;gt;&amp;quot;);
      } else {
          print(&amp;quot;Your login failed&amp;lt;br/&amp;gt;&amp;quot;);
      }
      print(&amp;quot;Would you like a cookie?&amp;lt;br/&amp;gt;&amp;lt;br/&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;\n&amp;quot;);
    }

    htmlz(login(param(&amp;quot;username&amp;quot;), param(&amp;quot;password&amp;quot;)));
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Exploit Exercises Nebula Level17</title>
      <link>https://mike-boya.github.io/blog/exploit-exercises-nebula-level17/</link>
      <pubDate>Mon, 22 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://mike-boya.github.io/blog/exploit-exercises-nebula-level17/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://exploit-exercises.com/nebula/level17/&#34; title=&#34;Level17&#34;&gt;Level17&lt;/a&gt; dictates, &amp;ldquo;There is a python script listening on port 10007 that contains a vulnerability.&amp;rdquo;&lt;/p&gt;
&lt;p&gt;Python! Nice. The nebula war game is using a variety of languages, which is fantastic. We are provided with the following source code:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    #!/usr/bin/python

    import os
    import pickle
    import time
    import socket
    import signal

    signal.signal(signal.SIGCHLD, signal.SIG_IGN)

    def server(skt):
      line = skt.recv(1024)

      obj = pickle.loads(line)

      for i in obj:
          clnt.send(&amp;quot;why did you send me &amp;quot; + i + &amp;quot;?\n&amp;quot;)

    skt = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
    skt.bind((&#39;0.0.0.0&#39;, 10007))
    skt.listen(10)

    while True:
      clnt, addr = skt.accept()

      if(os.fork() == 0):
          clnt.send(&amp;quot;Accepted connection from %s:%d&amp;quot; % (addr[0], addr[1]))
          server(clnt)
          exit(1)
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Exploit Exercises Nebula Level18</title>
      <link>https://mike-boya.github.io/blog/exploit-exercises-nebula-level18/</link>
      <pubDate>Mon, 22 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://mike-boya.github.io/blog/exploit-exercises-nebula-level18/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://exploit-exercises.com/nebula/level18/&#34; title=&#34;Level18&#34;&gt;Level18&lt;/a&gt; provides us with this large snippet of code:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    #include &amp;lt;stdlib.h&amp;gt;
    #include &amp;lt;unistd.h&amp;gt;
    #include &amp;lt;string.h&amp;gt;
    #include &amp;lt;stdio.h&amp;gt;
    #include &amp;lt;sys/types.h&amp;gt;
    #include &amp;lt;fcntl.h&amp;gt;
    #include &amp;lt;getopt.h&amp;gt;

    struct {
      FILE *debugfile;
      int verbose;
      int loggedin;
    } globals;

    #define dprintf(...) if(globals.debugfile) \
      fprintf(globals.debugfile, __VA_ARGS__)
    #define dvprintf(num, ...) if(globals.debugfile &amp;amp;&amp;amp; globals.verbose &amp;gt;= num) \
      fprintf(globals.debugfile, __VA_ARGS__)

    #define PWFILE &amp;quot;/home/flag18/password&amp;quot;

    void login(char *pw)
    {
      FILE *fp;

      fp = fopen(PWFILE, &amp;quot;r&amp;quot;);
      if(fp) {
          char file[64];

          if(fgets(file, sizeof(file) - 1, fp) == NULL) {
              dprintf(&amp;quot;Unable to read password file %s\n&amp;quot;, PWFILE);
              return;
          }
                    fclose(fp);
          if(strcmp(pw, file) != 0) return;
      }
      dprintf(&amp;quot;logged in successfully (with%s password file)\n&amp;quot;,
          fp == NULL ? &amp;quot;out&amp;quot; : &amp;quot;&amp;quot;);

      globals.loggedin = 1;

    }

    void notsupported(char *what)
    {
      char *buffer = NULL;
      asprintf(&amp;amp;buffer, &amp;quot;--&amp;gt; [%s] is unsupported at this current time.\n&amp;quot;, what);
      dprintf(what);
      free(buffer);
    }

    void setuser(char *user)
    {
      char msg[128];

      sprintf(msg, &amp;quot;unable to set user to &#39;%s&#39; -- not supported.\n&amp;quot;, user);
      printf(&amp;quot;%s\n&amp;quot;, msg);

    }

    int main(int argc, char **argv, char **envp)
    {
      char c;

      while((c = getopt(argc, argv, &amp;quot;d:v&amp;quot;)) != -1) {
          switch(c) {
              case &#39;d&#39;:
                  globals.debugfile = fopen(optarg, &amp;quot;w+&amp;quot;);
                  if(globals.debugfile == NULL) err(1, &amp;quot;Unable to open %s&amp;quot;, optarg);
                  setvbuf(globals.debugfile, NULL, _IONBF, 0);
                  break;
              case &#39;v&#39;:
                  globals.verbose++;
                  break;
          }
      }

      dprintf(&amp;quot;Starting up. Verbose level = %d\n&amp;quot;, globals.verbose);

      setresgid(getegid(), getegid(), getegid());
      setresuid(geteuid(), geteuid(), geteuid());

      while(1) {
          char line[256];
          char *p, *q;

          q = fgets(line, sizeof(line)-1, stdin);
          if(q == NULL) break;
          p = strchr(line, &#39;\n&#39;); if(p) *p = 0;
          p = strchr(line, &#39;\r&#39;); if(p) *p = 0;

          dvprintf(2, &amp;quot;got [%s] as input\n&amp;quot;, line);

          if(strncmp(line, &amp;quot;login&amp;quot;, 5) == 0) {
              dvprintf(3, &amp;quot;attempting to login\n&amp;quot;);
              login(line + 6);
          } else if(strncmp(line, &amp;quot;logout&amp;quot;, 6) == 0) {
              globals.loggedin = 0;
          } else if(strncmp(line, &amp;quot;shell&amp;quot;, 5) == 0) {
              dvprintf(3, &amp;quot;attempting to start shell\n&amp;quot;);
              if(globals.loggedin) {
                  execve(&amp;quot;/bin/sh&amp;quot;, argv, envp);
                  err(1, &amp;quot;unable to execve&amp;quot;);
              }
              dprintf(&amp;quot;Permission denied\n&amp;quot;);
          } else if(strncmp(line, &amp;quot;logout&amp;quot;, 4) == 0) {
              globals.loggedin = 0;
          } else if(strncmp(line, &amp;quot;closelog&amp;quot;, 8) == 0) {
              if(globals.debugfile) fclose(globals.debugfile);
              globals.debugfile = NULL;
          } else if(strncmp(line, &amp;quot;site exec&amp;quot;, 9) == 0) {
              notsupported(line + 10);
          } else if(strncmp(line, &amp;quot;setuser&amp;quot;, 7) == 0) {
              setuser(line + 8);
          }
      }

      return 0;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It also provides us with these directions:&lt;/p&gt;
&lt;p&gt;&amp;ldquo;Analyze the C program, and look for vulnerabilities in the program. There is an easy way to solve this level, an intermediate way to solve it, and a more difficult/unreliable way to solve it.&amp;rdquo;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Exploit Exercises Nebula Level19</title>
      <link>https://mike-boya.github.io/blog/exploit-exercises-nebula-level19/</link>
      <pubDate>Mon, 22 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://mike-boya.github.io/blog/exploit-exercises-nebula-level19/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://exploit-exercises.com/nebula/level19/&#34; title=&#34;Level19&#34;&gt;Level19&lt;/a&gt; provides us with the following code:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    #include &amp;lt;stdlib.h&amp;gt;
    #include &amp;lt;unistd.h&amp;gt;
    #include &amp;lt;string.h&amp;gt;
    #include &amp;lt;sys/types.h&amp;gt;
    #include &amp;lt;stdio.h&amp;gt;
    #include &amp;lt;fcntl.h&amp;gt;
    #include &amp;lt;sys/stat.h&amp;gt;

    int main(int argc, char **argv, char **envp)
    {
      pid_t pid;
      char buf[256];
      struct stat statbuf;

      /* Get the parent&#39;s /proc entry, so we can verify its user id */

      snprintf(buf, sizeof(buf)-1, &amp;quot;/proc/%d&amp;quot;, getppid());

      /* stat() it */

      if(stat(buf, &amp;amp;statbuf) == -1) {
          printf(&amp;quot;Unable to check parent process\n&amp;quot;);
          exit(EXIT_FAILURE);
      }

      /* check the owner id */

      if(statbuf.st_uid == 0) {
          /* If root started us, it is ok to start the shell */

          execve(&amp;quot;/bin/sh&amp;quot;, argv, envp);
          err(1, &amp;quot;Unable to execve&amp;quot;);
      }

      printf(&amp;quot;You are unauthorized to run this program\n&amp;quot;);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And this very detailed hint:&lt;/p&gt;
&lt;p&gt;&amp;ldquo;There is a flaw in the below program in how it operates.&amp;rdquo;&lt;/p&gt;
&lt;p&gt;&amp;hellip;No way!!&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Exploit Exercises Nebula Level13</title>
      <link>https://mike-boya.github.io/blog/exploit-exercises-nebula-level13/</link>
      <pubDate>Sat, 20 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://mike-boya.github.io/blog/exploit-exercises-nebula-level13/</guid>
      <description>&lt;p&gt;In &lt;a href=&#34;https://exploit-exercises.com/nebula/level13/&#34; title=&#34;Level13&#34;&gt;Level13&lt;/a&gt; we are given the following code:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    #include &amp;lt;stdlib.h&amp;gt;
    #include &amp;lt;unistd.h&amp;gt;
    #include &amp;lt;stdio.h&amp;gt;
    #include &amp;lt;sys/types.h&amp;gt;
    #include &amp;lt;string.h&amp;gt;

    #define FAKEUID 1000

    int main(int argc, char **argv, char **envp)
    {
      int c;
      char token[256];

      if(getuid() != FAKEUID) {
          printf(&amp;quot;Security failure detected. UID %d started us, we expect %d\n&amp;quot;, getuid(), FAKEUID);
          printf(&amp;quot;The system administrators will be notified of this violation\n&amp;quot;);
          exit(EXIT_FAILURE);
      }

      // snip, sorry :)

      printf(&amp;quot;your token is %s\n&amp;quot;, token);

    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In order to receive the token we need to &lt;strong&gt;FAKE&lt;/strong&gt; our UID to bypass the &lt;em&gt;if&lt;/em&gt; statement.&lt;/p&gt;
&lt;p&gt;Now, we could solve this a few different ways. The two that pop into mind are: 1.) Write a fake getuid() program to trick the call. 2.) Use a debugger.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Exploit Exercises Nebula Level14</title>
      <link>https://mike-boya.github.io/blog/exploit-exercises-nebula-level14/</link>
      <pubDate>Sat, 20 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://mike-boya.github.io/blog/exploit-exercises-nebula-level14/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://exploit-exercises.com/nebula/level14/&#34; title=&#34;Level14&#34;&gt;Level14&lt;/a&gt; provides us with these instructions:&lt;/p&gt;
&lt;p&gt;&amp;ldquo;This program resides in /home/flag14/flag14. It encrypts input and writes it to standard output. An encrypted token file is also in that home directory, decrypt it :)&amp;rdquo;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Exploit Exercises Nebula Level11</title>
      <link>https://mike-boya.github.io/blog/exploit-exercises-nebula-level11/</link>
      <pubDate>Fri, 19 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://mike-boya.github.io/blog/exploit-exercises-nebula-level11/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://exploit-exercises.com/nebula/level11/&#34; title=&#34;Level11&#34;&gt;Level11&lt;/a&gt; provides us with the source code for level11.c:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;      #include &amp;lt;stdlib.h&amp;gt;
      #include &amp;lt;unistd.h&amp;gt;
      #include &amp;lt;string.h&amp;gt;
      #include &amp;lt;sys/types.h&amp;gt;
      #include &amp;lt;fcntl.h&amp;gt;
      #include &amp;lt;stdio.h&amp;gt;
      #include &amp;lt;sys/mman.h&amp;gt;

      /*
       * Return a random, non-predictable file, and return the file descriptor for it.
       */

      int getrand(char **path)
      {
        char *tmp;
        int pid;
        int fd;

        srandom(time(NULL));

        tmp = getenv(&amp;quot;TEMP&amp;quot;);
        pid = getpid();

        asprintf(path, &amp;quot;%s/%d.%c%c%c%c%c%c&amp;quot;, tmp, pid,
            &#39;A&#39; + (random() % 26), &#39;0&#39; + (random() % 10),
            &#39;a&#39; + (random() % 26), &#39;A&#39; + (random() % 26),
            &#39;0&#39; + (random() % 10), &#39;a&#39; + (random() % 26));

        fd = open(*path, O_CREAT|O_RDWR, 0600);
        unlink(*path);
        return fd;
      }

      void process(char *buffer, int length)
      {
        unsigned int key;
        int i;

        key = length &amp;amp; 0xff;

        for(i = 0; i &amp;lt; length; i++) {
            buffer[i] ^= key;
            key -= buffer[i];
        }

        system(buffer);
      }

      #define CL &amp;quot;Content-Length: &amp;quot;

      int main(int argc, char **argv)
      {
        char line[256];
        char buf[1024];
        char *mem;
        int length;
        int fd;
        char *path;

        if(fgets(line, sizeof(line), stdin) == NULL) {
            errx(1, &amp;quot;reading from stdin&amp;quot;);
        }

        if(strncmp(line, CL, strlen(CL)) != 0) {
            errx(1, &amp;quot;invalid header&amp;quot;);
        }

        length = atoi(line + strlen(CL));

        if(length &amp;lt; sizeof(buf)) {
            if(fread(buf, length, 1, stdin) != length) {
                err(1, &amp;quot;fread length&amp;quot;);
            }
            process(buf, length);
        } else {
            int blue = length;
            int pink;

            fd = getrand(&amp;amp;path);

            while(blue &amp;gt; 0) {
                printf(&amp;quot;blue = %d, length = %d, &amp;quot;, blue, length);

                pink = fread(buf, 1, sizeof(buf), stdin);
                printf(&amp;quot;pink = %d\n&amp;quot;, pink);

                if(pink &amp;lt;= 0) {
                    err(1, &amp;quot;fread fail(blue = %d, length = %d)&amp;quot;, blue, length);
                }
                write(fd, buf, pink);

                blue -= pink;
            }

            mem = mmap(NULL, length, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, 0);
            if(mem == MAP_FAILED) {
                err(1, &amp;quot;mmap&amp;quot;);
            }
            process(mem, length);
        }

      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;ldquo;There are two ways of completing this level, you may wish to do both :-)&amp;rdquo; - That sounds cool. Let&amp;rsquo;s take a look.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Exploit Exercises Nebula Level12</title>
      <link>https://mike-boya.github.io/blog/exploit-exercises-nebula-level12/</link>
      <pubDate>Fri, 19 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://mike-boya.github.io/blog/exploit-exercises-nebula-level12/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://exploit-exercises.com/nebula/level12/&#34; title=&#34;Level12&#34;&gt;Level12&lt;/a&gt; informs us that &amp;ldquo;There is a backdoor process listening on port 50001.&amp;rdquo;&lt;/p&gt;
&lt;p&gt;We are also provided with &lt;strong&gt;level12.lua&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    local socket = require(&amp;quot;socket&amp;quot;)
    local server = assert(socket.bind(&amp;quot;127.0.0.1&amp;quot;, 50001))

    function hash(password)
      prog = io.popen(&amp;quot;echo &amp;quot;..password..&amp;quot; | sha1sum&amp;quot;, &amp;quot;r&amp;quot;)
      data = prog:read(&amp;quot;*all&amp;quot;)
      prog:close()

      data = string.sub(data, 1, 40)

      return data
    end


    while 1 do
      local client = server:accept()
      client:send(&amp;quot;Password: &amp;quot;)
      client:settimeout(60)
      local line, err = client:receive()
      if not err then
          print(&amp;quot;trying &amp;quot; .. line) -- log from where ;\
          local h = hash(line)

          if h ~= &amp;quot;4754a4f4bd5787accd33de887b9250a0691dd198&amp;quot; then
              client:send(&amp;quot;Better luck next time\n&amp;quot;);
          else
              client:send(&amp;quot;Congrats, your token is 413**CARRIER LOST**\n&amp;quot;)
          end

      end

      client:close()
    end
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Exploit Exercises Nebula Level08</title>
      <link>https://mike-boya.github.io/blog/exploit-exercises-nebula-level08/</link>
      <pubDate>Mon, 15 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://mike-boya.github.io/blog/exploit-exercises-nebula-level08/</guid>
      <description>&lt;p&gt;&amp;ldquo;World readable files strike again. Check what that user was up to, and use it to log into flag08 account.&amp;rdquo;&lt;/p&gt;
&lt;p&gt;This was the verbiage provided in the &lt;em&gt;About&lt;/em&gt; section for &lt;a href=&#34;https://exploit-exercises.com/nebula/level08/&#34; title=&#34;Level08&#34;&gt;level08&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Exploit Exercises Nebula Level09</title>
      <link>https://mike-boya.github.io/blog/exploit-exercises-nebula-level09/</link>
      <pubDate>Mon, 15 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://mike-boya.github.io/blog/exploit-exercises-nebula-level09/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://exploit-exercises.com/nebula/level09/&#34; title=&#34;Level09&#34;&gt;Level09&lt;/a&gt; provides us with a C setuid wrapper for some vulnerable PHP code.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    &amp;lt;?php

    function spam($email)
    {
      $email = preg_replace(&amp;quot;/\./&amp;quot;, &amp;quot; dot &amp;quot;, $email);
      $email = preg_replace(&amp;quot;/@/&amp;quot;, &amp;quot; AT &amp;quot;, $email);

      return $email;
    }

    function markup($filename, $use_me)
    {
      $contents = file_get_contents($filename);

      $contents = preg_replace(&amp;quot;/(\[email (.*)\])/e&amp;quot;, &amp;quot;spam(\&amp;quot;\\2\&amp;quot;)&amp;quot;, $contents);
      $contents = preg_replace(&amp;quot;/\[/&amp;quot;, &amp;quot;&amp;lt;&amp;quot;, $contents);
      $contents = preg_replace(&amp;quot;/\]/&amp;quot;, &amp;quot;&amp;gt;&amp;quot;, $contents);

      return $contents;
    }

    $output = markup($argv[1], $argv[2]);

    print $output;

    ?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see in the code above, the second argument &amp;ndash; $use_me &amp;ndash; is not used in the code.&lt;/p&gt;
&lt;p&gt;After doing some research, multiple sources identified preg_replace() as a dangerous feature that was deprecated in PHP 5.5.0 and removed as of PHP 7.0.0.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Exploit Exercises Nebula Level10</title>
      <link>https://mike-boya.github.io/blog/exploit-exercises-nebula-level10/</link>
      <pubDate>Mon, 15 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://mike-boya.github.io/blog/exploit-exercises-nebula-level10/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://exploit-exercises.com/nebula/level10/&#34; title=&#34;Level10&#34;&gt;level10&lt;/a&gt; provides us with the following source code:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    #include &amp;lt;stdlib.h&amp;gt;
    #include &amp;lt;unistd.h&amp;gt;
    #include &amp;lt;sys/types.h&amp;gt;
    #include &amp;lt;stdio.h&amp;gt;
    #include &amp;lt;fcntl.h&amp;gt;
    #include &amp;lt;errno.h&amp;gt;
    #include &amp;lt;sys/socket.h&amp;gt;
    #include &amp;lt;netinet/in.h&amp;gt;
    #include &amp;lt;string.h&amp;gt;

    int main(int argc, char **argv)
    {
      char *file;
      char *host;

      if(argc &amp;lt; 3) {
          printf(&amp;quot;%s file host\n\tsends file to host if you have access to it\n&amp;quot;, argv[0]);
          exit(1);
      }

      file = argv[1];
      host = argv[2];

      if(access(argv[1], R_OK) == 0) {
          int fd;
          int ffd;
          int rc;
          struct sockaddr_in sin;
          char buffer[4096];

          printf(&amp;quot;Connecting to %s:18211 .. &amp;quot;, host); fflush(stdout);

          fd = socket(AF_INET, SOCK_STREAM, 0);

          memset(&amp;amp;sin, 0, sizeof(struct sockaddr_in));
          sin.sin_family = AF_INET;
          sin.sin_addr.s_addr = inet_addr(host);
          sin.sin_port = htons(18211);

          if(connect(fd, (void *)&amp;amp;sin, sizeof(struct sockaddr_in)) == -1) {
              printf(&amp;quot;Unable to connect to host %s\n&amp;quot;, host);
              exit(EXIT_FAILURE);
          }

    #define HITHERE &amp;quot;.oO Oo.\n&amp;quot;
          if(write(fd, HITHERE, strlen(HITHERE)) == -1) {
              printf(&amp;quot;Unable to write banner to host %s\n&amp;quot;, host);
              exit(EXIT_FAILURE);
          }
    #undef HITHERE

          printf(&amp;quot;Connected!\nSending file .. &amp;quot;); fflush(stdout);

          ffd = open(file, O_RDONLY);
          if(ffd == -1) {
              printf(&amp;quot;Damn. Unable to open file\n&amp;quot;);
              exit(EXIT_FAILURE);
          }

          rc = read(ffd, buffer, sizeof(buffer));
          if(rc == -1) {
              printf(&amp;quot;Unable to read from file: %s\n&amp;quot;, strerror(errno));
              exit(EXIT_FAILURE);
          }

          write(fd, buffer, rc);

          printf(&amp;quot;wrote file!\n&amp;quot;);

      } else {
          printf(&amp;quot;You don&#39;t have access to %s\n&amp;quot;, file);
      }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This challenge is a tough one, we need to trigger the race condition within the code.&lt;/p&gt;
&lt;p&gt;The man page for access() confirms the suspicion: &amp;ldquo;&lt;strong&gt;Warning:&lt;/strong&gt; Using access() to check if a user is authorized to,
for example, open a file before actually doing so using open(2) creates a security  hole,  because  the  user
might exploit the short time interval between checking and opening the file to manipulate it.  For this reason,
the use of this system call should be avoided.&amp;rdquo; - Let&amp;rsquo;s see if we can cause that to occur on &lt;em&gt;line 24&lt;/em&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Exploit Exercises Nebula Level07</title>
      <link>https://mike-boya.github.io/blog/exploit-exercises-nebula-level07/</link>
      <pubDate>Sun, 14 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://mike-boya.github.io/blog/exploit-exercises-nebula-level07/</guid>
      <description>&lt;p&gt;The next level provides us with some perl code:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    #!/usr/bin/perl

    use CGI qw{param};

    print &amp;quot;Content-type: text/html\n\n&amp;quot;;

    sub ping {
    $host = $_[0];

    print(&amp;quot;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;Ping results&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;pre&amp;gt;&amp;quot;);

    @output = `ping -c 3 $host 2&amp;gt;&amp;amp;1`;
    foreach $line (@output) { print &amp;quot;$line&amp;quot;; }

    print(&amp;quot;&amp;lt;/pre&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&amp;quot;);

    }

    # check if Host set. if not, display normal page, etc

    ping(param(&amp;quot;Host&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Exploit Exercises Nebula Level06</title>
      <link>https://mike-boya.github.io/blog/exploit-exercises-nebula-level06/</link>
      <pubDate>Tue, 09 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://mike-boya.github.io/blog/exploit-exercises-nebula-level06/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://exploit-exercises.com/nebula/level06/&#34; title=&#34;Level06&#34;&gt;Level06&lt;/a&gt; specifies that &amp;ldquo;The &lt;strong&gt;flag06&lt;/strong&gt; account credentials came from a legacy unix system.&amp;rdquo;&lt;/p&gt;
&lt;p&gt;I believe the hint spells out exactly what we need to solve this level.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Nebula Level05</title>
      <link>https://mike-boya.github.io/blog/exploit-exercises-nebula-level05/</link>
      <pubDate>Mon, 08 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://mike-boya.github.io/blog/exploit-exercises-nebula-level05/</guid>
      <description>&lt;p&gt;[Level05] instructs us to &amp;ldquo;Check the flag05 home directory. You are looking for weak directory permissions&amp;rdquo;&lt;/p&gt;
&lt;p&gt;After navigating over to /home/flag05, we take a look at the permissions.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    level05@nebula:~$ pushd /home/flag05/
    level05@nebula:/home/flag05$ ls -al
    total 5
    drwxr-x--- 4 flag05 level05   93 2012-08-18 06:56 .
    drwxr-xr-x 1 root   root      80 2012-08-27 07:18 ..
    drwxr-xr-x 2 flag05 flag05    42 2011-11-20 20:13 .backup
    -rw-r--r-- 1 flag05 flag05   220 2011-05-18 02:54 .bash_logout
    -rw-r--r-- 1 flag05 flag05  3353 2011-05-18 02:54 .bashrc
    -rw-r--r-- 1 flag05 flag05   675 2011-05-18 02:54 .profile
    drwx------ 2 flag05 flag05    70 2011-11-20 20:13 .ssh
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Nebula Level03</title>
      <link>https://mike-boya.github.io/blog/exploit-exercises-nebula-level03/</link>
      <pubDate>Tue, 18 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>https://mike-boya.github.io/blog/exploit-exercises-nebula-level03/</guid>
      <description>&lt;p&gt;The details page for &lt;a href=&#34;https://exploit-exercises.com/nebula/level03/&#34; title=&#34;Level03&#34;&gt;Level03&lt;/a&gt; contains a hint directing us to the home directory of flag03. After navigating to the target home directory and listing out the files, I was presented with a shell script called writable.sh and a directory called writable.d.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Nebula Level04</title>
      <link>https://mike-boya.github.io/blog/exploit-exercises-nebula-level04/</link>
      <pubDate>Tue, 18 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>https://mike-boya.github.io/blog/exploit-exercises-nebula-level04/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://exploit-exercises.com/nebula/level04/&#34; title=&#34;Level04&#34;&gt;Level04&lt;/a&gt; was one of my favorite challenges out of the entire series. The post below documents my solution.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Nebula Level01</title>
      <link>https://mike-boya.github.io/blog/exploit-exercises-nebula-level01/</link>
      <pubDate>Tue, 14 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>https://mike-boya.github.io/blog/exploit-exercises-nebula-level01/</guid>
      <description>&lt;p&gt;The next level, &lt;a href=&#34;https://exploit-exercises.com/nebula/level01/&#34; title=&#34;Level01&#34;&gt;Level01&lt;/a&gt;, provides some C code for the user to evaluate. The code contains a vulnerability that allows arbitrary programs to be executed. This post will outline the steps I took to solve the challenge.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Nebula Level02</title>
      <link>https://mike-boya.github.io/blog/exploit-exercises-nebula-level02/</link>
      <pubDate>Tue, 14 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>https://mike-boya.github.io/blog/exploit-exercises-nebula-level02/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://exploit-exercises.com/nebula/level02/&#34; title=&#34;Level02&#34;&gt;Level02&lt;/a&gt; instructs us to review some vulnerable C code and locate the attack vector. This program addresses the vulnerability from the previous level but a new vector is available.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Exploit Exercises - Nebula Level00</title>
      <link>https://mike-boya.github.io/blog/exploit-exercises-nebula-level00/</link>
      <pubDate>Fri, 10 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>https://mike-boya.github.io/blog/exploit-exercises-nebula-level00/</guid>
      <description>&lt;p&gt;After completing some of my certifications, I decided to get back to some of the challenges and coding practice. My good friend Kristian suggested the war games over at &lt;a href=&#34;https://exploit-exercises.com/&#34; title=&#34;Exploit Exercises&#34;&gt;Exploit Exercises&lt;/a&gt;. Starting with &lt;a href=&#34;https://exploit-exercises.com/nebula/&#34; title=&#34;Nebula&#34;&gt;Nebula&lt;/a&gt;, I will outline some walkthroughs of my solutions to the levels (00-19). I will split each level into a separate post in order to not spoil any of the challenges for someone just looking for a hint on a single level.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://exploit-exercises.com/nebula/level00/&#34; title=&#34;Level00&#34;&gt;Level00&lt;/a&gt; requires you to locate a Set User ID program that will run as the &amp;ldquo;flag00&amp;rdquo; account. The &amp;ldquo;About&amp;rdquo; section hints at checking out the man page for the find command.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
